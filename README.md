1. Система типов: nullable-типы
    Одной из самых известных особенностей Kotlin является разделение типов на nullable (которые могут
    принимать `null` в качестве значения) и на not-null типы. Nullable типы объявляются со знаком вопроса,
    например `String?`, `Int?` или, например, `Array<Int?>?`. Основное преимущество -- явно разделять 
    типы, которые могут и не могут принимать `null`. По статистике большинство исключений, которые возникают
    в Java являются NullPointerException'ами. Новая система типов существенно помогает решить эту проблему.
2. Система типов: `Nothing`
    В джаве, как и в большинстве современных языков, явно проверяется, что функция по любому пути исполнения
    возвращает некоторое значение. Например, следующий код на Java:
    ```java
    int foo(int x) {
        if (x > 0)
            return 1;
        // Здесь будет ошибка компиляции -- не возвращается никакое значение
    }
    ```
    Однако, есть выражения, которые меняют поток исполнение, например:
    ```java
    int foo(int x) {
        if (x > 0)
            return 1;
        throw new RuntimeException("x must be positive");
        // Здесь не будет ошибки, потому что поток управление не может пройти через throw
    }
    ```
    Но что, если ты хочешь кидать исключения не с помощью throw, а с помощью специальной функции, например,
    `error`, которая перед исключением выводит что-то на консоль?
    ```java
    void error(String message) {
        System.err.println(message);
        throw new RuntimeException(message);
    }
    
    int foo(int x) {
        if (x > 0)
            return 1;
        error("x must be positive");
        // Снова ошибка, должен быть return
    }
    ```
    В таком случае Java никак не может проверить, что функция `error` никогда не выполнится, поэтому
    она требует, чтобы после `error` был `return` или `throw`. Однако в Kotlin для этого есть решение:
    специальный тип `Nothing`. Тип `Nothing` ненаселен, то есть не существует значения, которое имеет такой тип.
    Если какое-то значение имеет тип `Nothing`, то оно никогда не завершится. Тип `Nothing` имеют операторы
    `return`, `break`, `continue`, `throw`, а также его можно получить в некоторых других ситуациях.
    Используя его в Kotlin можно написать функцию `error` с правильным поведением:
    ```kotlin
    fun error(message: String): Nothing {
        System.err.println(message)
        throw RuntimeException(message)
    }
    
    fun foo(x: Int): Int {
        if (x > 0)
            return 1
        error("x must be positive")
        // Никакой ошибки, успешная компиляция
    }
    ```
    Также существует множество других красивых применений типа `Nothing`. Вот пример: Пусть есть список 
    `list: List<String?>`. Хочется в цикле перебрать все значения списка и вывести только те, которые не 
    `null`. Можно это сделать топорным кодом:
    ```kotlin
    for (s in list) {
        if (s != null)
            println(s)
    }
    ```
    Однако, гораздо более удобным и красивым будет следующий способ. Он использует тот факт, что `continue` имеет
    тип `Nothing`, что `Nothing` является подтипом любого типа, а также специальный оператор Элвиса `?:`, который
    работает следующим образом: `a ?: b` эквивалентно `a != null ? a : b`. Сам код:
    ```kotlin
    for (s in list) {
        val string = s ?: continue
        println(string)
    }
    ```
    Этот код работает, потому что `continue` можно положить в переменную любого типа, так как `Nothing` является
    подтипом любого типа. Однако эффективно при вычислении `continue` будет выполнен пропуск итерации цикла, таким 
    образом в `string` попадут только неnullовые значения списка. Существует еще тонна применений типу `Nothing`, 
    например `null` имеет тип `Nothing?`, но их слишком много, чтобы пытаться рассказать все.
